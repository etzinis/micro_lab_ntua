DATA_SEG    SEGMENT 
     
    NUMBERS 100 DUP(0)
    MS1 DB  0AH,0DH,"GIVE DECIMAL DIGITS :$"
    MS2 DB  0AH,0DH,"HEX=$" 
    MS3 DB  0AH,0DH,"THE MAXIMUM NUMBER OF DIGITS MUST BE 100 $"  
    INDEX1 DB 0      ;POINTER TO THE FIRST NON ZERO ELEMENT OF THE ARRAY NUMBERS
    INDEX2 DB 0      ;POINTER TO THE LAST ELEMENT OF THE ARRAY NUMBERS
    CHECK DB 0       
    CHECK2 DB 0
    COUNTER DB 0
      COUNTER2 DB 0
DATA_SEG    ENDS
    
CODE_SEG SEGMENT
    ASSUME CS:CODE_SEG,DS:DATA_SEG
    

PRINT_STR MACRO STRING    ;MACRO TO PRINT A STRING
    MOV DX,OFFSET STRING
    MOV AH,9
    INT 21H   
    
ENDM  

PRINT MACRO CHAR       ;MICRO TO PRINT A CHAR
    MOV DL,CHAR
    MOV AH,2H
    INT 21H
ENDM
 
 
DECTOHEX PROC NEAR  
    LOOP_1:
        CMP CH,0
        JZ EXIT1
        ADD CL,0AH
        DEC CH
        JMP LOOP_1
EXIT1:RET
   
DECTOHEX ENDP   
 
 

PRINT_HEX PROC NEAR 
    CMP DL,9
    JLE ADDR3
    ADD DL,37H
    JMP ADDR4
ADDR3:
    ADD DL,30H
ADDR4:
    MOV AH,02H
    INT 21H
    RET
PRINT_HEX ENDP   

       
READ_NUM PROC NEAR      ;PROC TO READ A NUMBER
     PUSH DX
        
IGNORE:
    MOV AH,08H      ;READ THE NUMBER
    INT 21H
    MOV CL,INDEX2
    CMP CL,4        ;CHECK IF I HAVE ALREADY READ 4 NUMBERS
    JL OXI_TELOS    
    CMP AL,0DH      ;IF SO CHECK FOR ENTER BUTTON
    JE TELOS
OXI_TELOS:
    CMP AL,30H      ;CHECK IF THE CHARACTER IS A NUMBER BETWEEN 0 AND 9
    JL IGNORE
    CMP AL,39H      ;IF NOT READ AGAIN
    JG IGNORE

    JMP KEEP_READING 
      
TELOS:
    MOV CHECK,1  ;IF ENTER BUTTON IS PUSHED THE CHECK=1
    
KEEP_READING:
    POP DX
    RET
READ_NUM ENDP       
       


 

MAIN PROC FAR
    MOV AX,DATA_SEG
    MOV DS,AX  
    
START:
    PRINT_STR MS3
    PRINT_STR MS1
    MOV BX,OFFSET NUMBERS   ;INITIALIZE BX TO THE FIRST ELEMENT OF ARRAY
    MOV CHECK,0
    MOV INDEX1,0
    MOV INDEX2,0  
    MOV COUNTER,0
    MOV CHECK2,0 
    
CREATE_ARRAY:    
     CALL READ_NUM   ;READ NUMBER
     CMP CHECK,1     ;CHECK IF ENTER BUTTON IS PUSHED
     JE ENDOF_ARRAY ;IF SO  STOP READING
     MOV [BX],AL     ;ELSE PUT THE NUMBER YOU READ TO THE ARRAY
     INC INDEX2      ;INCREASE INDEX2
     INC BX          ;GET TO THE NEXT CELL OF THE ARRAY
     JMP CREATE_ARRAY
     
ENDOF_ARRAY:
     MOV BX,OFFSET NUMBERS 
       
     
FIND_NONZERO_ELEMENT:                ;FINDS THE PLACE OF THE FIRST NON ZERO ELEMENT
     MOV CL,INDEX1
     MOV CH,INDEX2
     CMP CL,CH  
     JG ENDOF_0
     MOV AL,[BX] 
     SUB AL,30H    ;GET THE ASCII CODE OF THE ELEMENT
     CMP AL,0      ;IF I FIND ONE NON ZERO ELEMENT I'M DONE
     JNE ENDOF_0 
     INC BX 
     INC INDEX1             
     JMP FIND_NONZERO_ELEMENT
     
ENDOF_0:
    MOV BX,OFFSET NUMBERS
    MOV CH,0
    MOV CL,INDEX2   ;CX=THE PLACE OF THE LAST ELEMENT OF ARRAY
    MOV AL,CL 
    SUB AL,INDEX1   ;COUNTER2=THE NUMBER OF THE ELEMENTS LEFT AFTER THE FIRST NON-ZERO
    MOV COUNTER2,AL 
    
PRINT_NUMS: 
    
    CMP CHECK2,1      ;IF WE HAVE NOT FOUND THE FIRST NON ZERO ELEMENT WE DONT HAVE TO PUT COMMA
    JNE NOT_COMMA
    MOV AL, COUNTER2     ;ELSE WE CHECK IF THE NON ZERO ELEMENTS LEFT ARE MULTIPLE OF 3
    MOV AH,0 
    MOV DH,3
    DIV DH  
    CMP AH,0  
    
    JNE NOT_COMMA       ;IF SO WE PUT COMMA
   
    MOV DL,2CH
    MOV AH,2
    INT 21H 
    
NOT_COMMA:  
    
    MOV DH,[BX] 
    PUSH AX            ;THEN WE PRINT THE NEXT ELEMENT OF THE ARRAY
    
    PRINT DH
    POP AX
    SUB DH,30H
    CMP CHECK2,1       ;WE CHECK IF CKECK2=1
    JE DECRONLY        ;IF SO WE DECREASE THE ELEMENTS LEFT
    CMP DH,0           ;IF NOT  WE CHECK IF THIS ELEMENT IS 0
    JE DONT_DECR       ;IF SO WE DO NOTHING
    MOV CHECK2,1       ;ELSE WE MAKE CHECK2=1
     
DECRONLY: 


   DEC COUNTER2         ;AND WE DECREASE THE COUNTER
   
DONT_DECR:
   
    INC BX
    LOOP PRINT_NUMS 
                                
INTO_HEX:
     MOV BX,OFFSET NUMBERS 
     MOV CL,INDEX2         
     MOV CH,0
     ADD BX,CX             ;CX=THE PLACE OF THE LAST ELEMENT OF THE ARRAY
     
     
    SUB BX,4
    
    MOV DL,[BX]
    SUB DL,30H            ;WE CHECK IF THE LAST 4 NUMBERS WE GOT ARE 307
    CMP DL,3              ;IF SO WE QUIT
    JNE OK 
    
    INC BX
    
    MOV DL,[BX]
    SUB DL,30H
    CMP DL,0
    JNE OK
    
    INC BX                ;IF NOT WE CONTINUE
    
    MOV DL,[BX]
    SUB DL,30H
    CMP DL,7
    JNE OK
    
    INC BX
     
    MOV DL,[BX] 
    SUB DL,30H
    CMP DL,6
    JE QUIT

     
OK:    
       ;MOV BX,OFFSET NUMBERS
       ;SUB BX,4
       PRINT_STR MS2
       MOV CX,0 
       MOV DX,0 
       MOV INDEX2,4    ;WE USE INDEX2 AS A COUNTER AS WE DONT NEED IT ANYMORE
       
LOOPA:   
     MOV DL,[BX]
     SUB DL,30H
     PUSH DX   
     MOV AX,10           ;I MAKE THE 4 DIGIT NUMBER FROM THE 4 LAST ELEMENTS OF THE ARRAY
     MUL CX
     MOV CX,AX           
     POP DX
     ADD CX,DX    
    
     INC BX 
     DEC INDEX2
     CMP INDEX2,0
     JG LOOPA
      
     MOV BX,CX
     MOV CX,4
    
ADDR2: 
    
    ROL BX,4              ;WE USE 4 RIGHT SLIDES TO TAKE EACH ONE OF THE NUMBER'S DIGITS
    MOV DX,BX
    AND DX,000FH
    CALL PRINT_HEX
    LOOP ADDR2
    JMP START
  
QUIT:
    MOV AX,4C00H
    INT 21H
    
CODE_SEG ENDS
   END MAIN 