
; You may customize this and other start-up templates; 
; The location of this template is c:\emu8086\inc\0_com_template.txt

  
READ MACRO   
    MOV AH,8
    INT 21H
ENDM 

PRINT_STR MACRO STRING
    MOV DX,OFFSET STRING
    MOV AH,9
    INT 21H 
ENDM    

PRINT MACRO CHAR
    MOV DL,CHAR
    MOV AH,2H
    INT 21H
ENDM

PRINT_MESSAGE MACRO MESSAGE  
    PRINT_STR MESSAGE
    PRINT_STR NEWLINE
ENDM

PRINT_ARRAY MACRO ARRAY, INDEXR
    LOCAL CHECKNEXT, EXIT_PRINT_ARRAY
    MOV BX,OFFSET ARRAY
    MOV CX,00H
    MOV CL,INDEXR             ;CL=COUNTER OF STORE ARRAY
    CMP CL,00H                ;IF CL IS ZERO THEN YOU DONT HAVE TO PRINT ANYTHING
    JZ EXIT_PRINT_ARRAY 
    
CHECKNEXT:  
    MOV DL,[BX]
    PRINT DL                    ;PRINT THE CHECKING CELL
    INC BX                      ;SHOW TO THE NEXT CELL
    LOOP CHECKNEXT              ;DO THAT FOR THE WHOLE ARRAY
EXIT_PRINT_ARRAY:
ENDM

UPDATE  MACRO ARRAY, INDEXR    ;IN THIS MACRO WE SUPPOSE THAT AL HAS THE VALUE WE WANT TO 
        
        MOV BX,OFFSET ARRAY   ;INITIALIZE IT TO THE FIRST ELEMENT OF ARRAY
        MOV DL,INDEXR         ;THE INDEX OF THE ARRAY    
        MOV DH,00H
        ADD BX,DX             ;BX IS IN THE NEXT POSITION WE WANT TO STORE
        MOV [BX],AL           ;OF COURSE AL HAS THE VALID INPUT NUMBER OR CHARACTER  
        INC INDEXR            ;COUNTER ++
        
ENDM

DATA SEGMENT
    BUFFER  DB "01234567890123" 
    NUMBERS DB "01234567890123"  ;BUFFER HAS 14 CELLS FOR EVERY POSSIBLE INPUT
    LOWERCASE DB "aaaaaaaaaaaaaa"
    UPPERCASE DB "AAAAAAAAAAAAAA"
    INDEXN DB 0
    INDEXL DB 0
    INDEXU DB 0
    INDEXB DB 0
    MAX1   DB 0
    MAX2   DB 0 
    WELC DB "PLEASE INSERT 14 CHARACTERS a-z OR A-Z OR ANY DECIMAL DIGITS",0AH,0DH,'$' 
    MSG1 DB "~YOU INSERTED~ $" 
    MSG2 DB "~LOWERCASE DIGITS UPPERCASE~ $"
    MSG3 DB "~MAX1 MAX2~ $"
    NO_DIG DB "~YOU HAVE NOT ENTERED ANY DIGITS!~ $"
    ONLY_ONE DB "~YOU HAVE ENTERED ONLY ONE DIGIT SO ITS THE MAX AS WELL~ $"
    BYE DB "ADIOS AMIGOS $"
    NEWLINE DB 0AH,0DH,'$'
DATA ENDS

CODE SEGMENT 
    ASSUME CS:CODE,DS:DATA 
   
MAIN PROC FAR

        MOV AX,DATA
        MOV DS,AX 
 
START:  PRINT_STR WELC
        MOV INDEXB,00H  ;WE WANT THE LOOP TO HAPPEN 14 DEC TIMES
        MOV INDEXN,00H
        MOV INDEXU,00H ;INDEXES INITIALIZATION
        MOV INDEXL,00H 
        MOV MAX1,30H
        MOV MAX2,30H    ;INITIALIZE THE MAXIMUM VALUES IN ZERO (30H IN ASCII)
        
LOOPA:  READ        ;READ A CHAR  WE STORE IT IN AL
        CMP AL,'='  ;CHECK IF WE HAVE PRESSED '=' THAT MEANS TERMINATE THE PROGRAM
        JZ TERMINATE 
        CMP AL,0DH  ;CHECK IF WE HAVE PRESSED ENTER
        JZ ENTER
        
        CMP AL,'0'
        JL LOOPA    ;IF IT HAS ASCII CODE < 0 ITS NOT VALID
        CMP AL,'9'  
        JLE DIGIT   ;IF IT IS BETWEEN 0 AND 9 ITS A DIGIT 
        
        CMP AL,'A'  ;IF ITS NOT A NUMBER AND ITS CODE < CODE(A) THEN NOT VALID
        JL LOOPA
        CMP AL,'Z'  ;IF ITS BETWEEN A , Z ITS A VALID UPPERCASE LETTER THEN SAVE IT
        JLE UPPERC
        
        CMP AL,'a'  ;IF ITS NOT A NUMBER AND ITS CODE < CODE(a) THEN NOT VALID
        JL LOOPA
        CMP AL,'z'  ;IF ITS BETWEEN a , z ITS A VALID LOWERCASE LETTER THEN SAVE IT
        JG LOOPA    ;ELSE IGNORE IT
        JMP LOWERC
        
DIGIT:  
FIRST_MAX:           ;INPUT NUMBER IS IN AL
        CMP AL,MAX1
        JL CONTINUE
        MOV MAX1,AL 
CONTINUE:        
        UPDATE NUMBERS, INDEXN
        JMP SAVE_IT 
        
UPPERC: UPDATE UPPERCASE, INDEXU
        JMP SAVE_IT 
        
LOWERC: UPDATE LOWERCASE, INDEXL
        
SAVE_IT:UPDATE BUFFER, INDEXB
        CMP INDEXB,0DH         ;WE WILL SAVE IT ONLY 14 DEC TIMES THEN WE OUTPUT
        JZ WAIT_FOR_IT         ;IF WE HAVE 14 CHARACTERS OR NUMBER THEN WAIT FOR ENTER TO SHOW IT
        JMP LOOPA              ;ALL THE BUFFER INPUT ANYWAY

WAIT_FOR_IT: 
        READ        ;READ A CHAR  WE STORE IT IN AL
        CMP AL,'='  ;CHECK IF WE HAVE PRESSED '=' THAT MEANS TERMINATE THE PROGRAM
        JZ TERMINATE 
        CMP AL,0DH  ;CHECK IF WE HAVE PRESSED ENTER
        JNZ WAIT_FOR_IT

        
ENTER:  PRINT_MESSAGE MSG1
        PRINT_ARRAY BUFFER, INDEXB   ;CALL THE MACRO TO SHOW ALL THE INPUT CHARS OR DIGITS
        PRINT_STR NEWLINE
        PRINT_MESSAGE MSG2
        PRINT_ARRAY LOWERCASE, INDEXL ;SHOW ONLY THE LOWERCASE CHARACTERS THAT YOU HAVE ENTERED
        CMP INDEXL,00H
        JZ CONTROL1                   ;DONT OUTPUT ANY SPACES IF WE DONT HAVE LOWERCASE CHARS
        PRINT ' '
CONTROL1:   
        PRINT_ARRAY NUMBERS, INDEXN   ;ONLY THE NUMBERS
        CMP INDEXN,00H
        JZ CONTROL2                   ;DONT OUTPUT ANY SPACES IF WE DONT HAVE DIGITS 
        PRINT ' '
CONTROL2:
        PRINT_ARRAY UPPERCASE, INDEXU ;ONLY THE UPPERCASE CHARACTERS
        PRINT_STR NEWLINE
        
FIND_THE_MAX: 
        
        CMP INDEXN, 00H
        JNZ HAS_1
        PRINT_MESSAGE NO_DIG 
        JMP EXIT
        
HAS_1:  CMP INDEXN, 01H 
        JNZ HAS_2_OR_MORE
        PRINT_MESSAGE ONLY_ONE
        PRINT MAX1
        JMP FOUND_MAX
               
HAS_2_OR_MORE: 

DO_MAX1_ZERO:                  
        MOV BX,OFFSET NUMBERS
        MOV CH,00H
        MOV CL,INDEXN             ;CL=COUNTER OF NUMBERS ARRAY
        
NEXT:
        MOV DL,[BX]
        CMP DL,MAX1
        JNZ CONT                ;IF WE DID NOT FIND MAX1 THEN CHECK THE NEXT DIGIT
        MOV [BX],30H            ;ELSE DO IT ZERO (30H)
        JMP EXIT_DO_MAX1_ZERO
CONT:   INC BX                      ;SHOW TO THE NEXT CELL
        LOOP NEXT              ;DO THAT FOR THE WHOLE ARRAY
EXIT_DO_MAX1_ZERO: 

FIND_MAX2:  ;NOW WE HAVE GET RID OFF MAX1 IN THE ARRAY SO WE JUST HAVE TO FIND THE MAX OF THESE VALUES
        MOV BX,OFFSET NUMBERS
        MOV CH,00H
        MOV CL,INDEXN             ;CL=COUNTER OF NUMBERS ARRAY
        MOV MAX2,30H            ;INITIALIZE MAX2 IN ZERO VALUE
NEXTF:  
        MOV DL,[BX]
        CMP DL,MAX2
        JLE CONTF                ;IF WE DID FIND A DIGIT LESS OR EQUAL THAN MAX2 THEN CHECK THE NEXT DIGIT
        MOV MAX2,DL            ;ELSE MAX2 <-THIS DIGIT
CONTF:  INC BX                      ;SHOW TO THE NEXT CELL
        LOOP NEXTF              ;DO THAT FOR THE WHOLE ARRAY
        
        PRINT_MESSAGE  MSG3
        PRINT MAX1
        PRINT ' '
        PRINT MAX2
        
FOUND_MAX: PRINT_STR NEWLINE 
    
EXIT:   JMP START     ;CONTINUOUS FUNCTIONALITY

TERMINATE:
        PRINT_STR BYE
        MOV AX,4C00H  ;RETURN TO DOS
        INT 21H
        MAIN ENDP    

CODE ENDS
END MAIN